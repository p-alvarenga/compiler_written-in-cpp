21-08-2025: 
	- Review the repeat of Token t(int, int) in each if/else statement in Lexer::tokenize
	- Start writting Parser class using std::vector<Token>; 


20-08-2025:
	[[ UPDATES ]]
		- Lexer probably good to go; 

	[[ TODO ]]
		- [ ] Review completly the Lexer class and optmize it's methods!!!
		- [ ] Recognize string literal ("string")
		- [ ] Review (in Lexer::tokenize) the way the numerical text is consumed!

17-08-2025:
	[[ UPDATE ]] The operator identificator is working properly.

	[[ TODO ]]
		- [x] Write the numerical identifier; (123 & 1.23)
		- [ ] Write CompileError class and it's derivatives (LexerError, ParserError...);


16-08-2025:
	[!] PROBLEM: Something is really strange in the system of recognizing operators. It follows the same structure of the keywords/id system. So the problem must be simple, solve it pls :) # Solved ;)
	

14-08-2025

	[!] PROBLEM: the Lexer::tokenize() function is identifing token by itself and not asking for identifyToken()
	[*] NOTE   : Write CompileError and its derivatives (LexerError, ParserError etc.) [with ::throw()]


12-08-2025:

	Todo.:
		1. [ ] Write Lexer::peek(size_t offset) function;
		2. [ ] Continue writting the tokenize function, processing OperatorChar(c); 

	Notes: 	
		1. Explore more the use of constexpr keyword
		2. optimize the Lexer::IdentifyToken() on IdentifierStart case;
		

09-08-2025: 

	Todo: 
		- [x] Optimize and simplify the Lexer::tokenize() function;
		- [x] Write the Lexer::identifyKeyword()  # doesn't exist anymore
		- [x] Write the Lexer::identifyToken() (maybe change the name too) # changed for Lexer::tokenize() 
